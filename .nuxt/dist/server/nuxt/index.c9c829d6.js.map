{"version":3,"file":"index.c9c829d6.js","sources":["../../../../pages/index.vue"],"sourcesContent":["<script setup lang=\"ts\">\r\nimport { onMounted } from '#imports'\r\n// let Dither = require('canvas-dither');\r\nuseHead({ title: \"1D Minesweeper\" });\r\n\r\nlet cellSize: number = 10;\r\nlet height: number = 20;\r\nlet width: number = 20;\r\nlet scene, ctx;\r\nconst score = ref(0);\r\nlet isOver: boolean = false;\r\n\r\nconst floor = new Image();\r\nfloor.src = \"./floor.png\";\r\nawait new Promise((resolve) => {\r\n    floor.onload = () => resolve(1);\r\n});\r\n\r\nconst foodTexture = new Image();\r\nfoodTexture.src = \"./food.png\";\r\nawait new Promise((resolve) => {\r\n    foodTexture.onload = () => resolve(1);\r\n});\r\n\r\nconst snake = {\r\n    x: 0,\r\n    y: 0,\r\n    velocityX: 0,\r\n    velocityY: 0,\r\n    tail: []\r\n}\r\n\r\nconst food = {\r\n    x: 0,\r\n    y: 0\r\n}\r\n\r\nonMounted(async ()=>{\r\n    scene = document.getElementById(\"scene\");\r\n    scene.height = height * cellSize;\r\n    scene.width = width * cellSize;\r\n    ctx = scene.getContext(\"2d\");\r\n\r\n    await updateFoodPos();\r\n    document.addEventListener(\"keydown\", changeDirection);\r\n    setInterval(renderFrame, 66.67); // 1000/15 = 66.67ms - 15fps\r\n});\r\n\r\nasync function renderFrame() {\r\n    if (isOver) {\r\n        return;\r\n    }\r\n\r\n    // background\r\n    // ctx.fillStyle = \"black\";\r\n    // ctx.fillRect(0, 0, scene.width, scene.height);\r\n    ctx.drawImage(floor, 0, 0);\r\n\r\n    // food\r\n    // ctx.fillStyle = 'rgb(219,157,169)';\r\n    // ctx.fillRect(food.x, food.y, cellSize, cellSize);\r\n    ctx.drawImage(foodTexture, food.x, food.y);\r\n\r\n    // snake\r\n    if (snake.x === food.x && snake.y === food.y) {\r\n        snake.tail.push([food.x, food.y]);\r\n        updateFoodPos();\r\n    }\r\n\r\n    for (let i = snake.tail.length - 1; i > 0; i--) {\r\n        snake.tail[i] = snake.tail[i - 1];\r\n    }\r\n\r\n    if (snake.tail.length) {\r\n        snake.tail[0] = [snake.x, snake.y];\r\n    }\r\n\r\n    snake.x += snake.velocityX * cellSize;\r\n    snake.y += snake.velocityY * cellSize;\r\n\r\n    if (snake.x < 0) {\r\n        snake.x = (width - 1) * cellSize;\r\n    }\r\n    if (snake.x > (width - 1) * cellSize) {\r\n        snake.x = 0;\r\n    }\r\n    if (snake.y < 0) {\r\n        snake.y = (height - 1) * cellSize;\r\n    }\r\n    if (snake.y > (height - 1) * cellSize) {\r\n        snake.y = 0;\r\n    }\r\n\r\n    ctx.fillStyle = 'white';\r\n    ctx.fillRect(snake.x, snake.y, cellSize, cellSize);\r\n\r\n    // tail\r\n    ctx.fillStyle = 'rgb(237, 230, 204)';\r\n    for (let i = 0; i < snake.tail.length; i++) {\r\n        ctx.fillRect(snake.tail[i][0], snake.tail[i][1], cellSize, cellSize);\r\n    }\r\n\r\n    //game over\r\n    for (let i = 0; i < snake.tail.length; i++) {\r\n        if (snake.x === snake.tail[i][0] && snake.y === snake.tail[i][1]) {\r\n            gameOver();\r\n        }\r\n    }\r\n\r\n    ditherFrame();\r\n}\r\n\r\nasync function ditherFrame() {\r\n    const lightRadius = 125;\r\n    const shadingCanvas = document.createElement(\"canvas\");\r\n    shadingCanvas.width = scene.width;\r\n    shadingCanvas.height = scene.height;\r\n    const shadingCtx = shadingCanvas.getContext(\"2d\");\r\n    shadingCtx.fillStyle = \"black\";\r\n    shadingCtx.fillRect(0, 0, scene.width, scene.height);\r\n\r\n    let gradient = shadingCtx.createRadialGradient(snake.x, snake.y, 0, snake.x, snake.y, lightRadius);\r\n    gradient.addColorStop(0.0, \"rgba(255, 255, 255, 255)\");\r\n    gradient.addColorStop(1.0, \"rgba(255, 255, 255, 0)\");\r\n    shadingCtx.beginPath();\r\n    shadingCtx.fillStyle = gradient;\r\n    shadingCtx.arc(snake.x, snake.y, lightRadius, 0, 2 * Math.PI);\r\n    shadingCtx.fill();\r\n\r\n    let gradient2 = shadingCtx.createRadialGradient(food.x, food.y, 0, food.x, food.y, lightRadius / 2);\r\n    gradient2.addColorStop(0.0, \"rgba(255, 255, 255, 255)\");\r\n    gradient2.addColorStop(1.0, \"rgba(255, 255, 255, 0)\");\r\n    shadingCtx.fillStyle = gradient2;\r\n    shadingCtx.arc(food.x, food.y, lightRadius / 2, 0, 2 * Math.PI);\r\n    shadingCtx.fill();\r\n\r\n    // screen overlay mode\r\n    let frame = ctx.getImageData(0, 0, scene.width, scene.height);\r\n    let mask = shadingCtx.getImageData(0, 0, shadingCanvas.width, shadingCanvas.height);\r\n\r\n    for (let i = 0; i < frame.data.length; i += 4) {\r\n        const brightness = mask.data[i] / 255;\r\n        frame.data[i] *= brightness;\r\n        frame.data[i + 1] *= brightness;\r\n        frame.data[i + 2] *= brightness;\r\n    }\r\n\r\n    ctx.putImageData(frame, 0, 0);\r\n\r\n    let image = ctx.getImageData(0, 0, scene.width, scene.height);\r\n    image = bayer(image, 128);\r\n    ctx.putImageData(image, 0, 0);\r\n}\r\n\r\nfunction bayer(image, threshold) {\r\n    const thresholdMap = [\r\n      [15, 135, 45, 165],\r\n      [195, 75, 225, 105],\r\n      [60, 180, 30, 150],\r\n      [240, 120, 210, 90],\r\n    ];\r\n\r\n    for (let i = 0; i < image.data.length; i += 4) {\r\n      const luminance = (image.data[i] * 0.299) + (image.data[i + 1] * 0.587) + (image.data[i + 2] * 0.114);\r\n\r\n      const x = i / 4 % image.width;\r\n      const y = Math.floor(i / 4 / image.width);\r\n      const map = Math.floor((luminance + thresholdMap[x % 4][y % 4]) / 2);\r\n      const value = map < threshold ? 0 : 255;\r\n      image.data.fill(value, i, i + 3);\r\n    }\r\n    return image;\r\n  }\r\n\r\nasync function updateFoodPos() {\r\n    food.x = Math.floor(Math.random() * width) * cellSize;\r\n    food.y = Math.floor(Math.random() * height) * cellSize;\r\n    score.value++;\r\n}\r\n\r\nfunction changeDirection(e) {\r\n    if ((e.code === \"ArrowUp\" || e.code === \"KeyW\") && snake.velocityY != 1) {\r\n        snake.velocityX = 0;\r\n        snake.velocityY = -1;\r\n    }\r\n    else if ((e.code === \"ArrowDown\" || e.code === \"KeyS\") && snake.velocityY != -1) {\r\n        snake.velocityX = 0;\r\n        snake.velocityY = 1;\r\n    }\r\n    else if ((e.code === \"ArrowLeft\" || e.code === \"KeyA\") && snake.velocityX != 1) {\r\n        snake.velocityX = -1;\r\n        snake.velocityY = 0;\r\n    }\r\n    else if ((e.code === \"ArrowRight\" || e.code === \"KeyD\") && snake.velocityX != -1) {\r\n        snake.velocityX = 1;\r\n        snake.velocityY = 0;\r\n    }\r\n}\r\n\r\nasync function gameOver() {\r\n    isOver = true;\r\n    score.value = 0;\r\n    snake.tail = [];\r\n}\r\n</script>\r\n\r\n<template>\r\n    <div class=\"flex justify-center flex-wrap flex-col items-center min-w-[300px] select-none\">\r\n        <p>Score: {{ score }}</p>\r\n        <canvas id=\"scene\" class=\"w-[95vw]\" style=\"image-rendering: pixelated\"></canvas>\r\n    </div>\r\n</template>"],"names":["useHead","score","ref","floor","__temp","__restore","_withAsyncContext","resolve","foodTexture"],"mappings":"2cAGAA,EAAA,CAAA,MAAA,gBAAA,CAAA,EAMA,MAAAC,EAAAC,EAAA,CAAA,EAGAC,EAAA,IAAA,MACAA,EAAA,IAAA,cACA,CAAAC,EAAAC,CAAA,EAAAC,EAAA,IAAA,IAAA,QAAAC,GAAA,CACIJ,EAAA,OAAA,IAAAI,EAAA,CAAA,CAA8B,CAAA,CAAA,EAAA,MAAAH,EAAAC,IAGlC,MAAAG,EAAA,IAAA,MACA,OAAAA,EAAA,IAAA,aACA,CAAAJ,EAAAC,CAAA,EAAAC,EAAA,IAAA,IAAA,QAAAC,GAAA,CACIC,EAAA,OAAA,IAAAD,EAAA,CAAA,CAAoC,CAAA,CAAA,EAAA,MAAAH,EAAAC"}